#    stl.py
#    Copyright (C) 2017 by CJP
#
#    This file is part of NeSTL.
#
#    NeSTL is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License.
#    (at your option) any later version.
#
#    NeSTL is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with NeSTL. If not, see <http://www.gnu.org/licenses/>.

import struct

from mesh import Mesh, Vector



def load(fh):
	#TODO: make it an option to read the text format

	#Read header
	text_format_magic = b'solid'
	header_start = fh.read(len(text_format_magic))
	if header_start == text_format_magic:
		raise Exception('Text format STL loading not yet supported')
	fh.read(80 - len(text_format_magic)) #read and ignore the rest of the header

	#Read number of triangles
	numTriangles = struct.unpack('<I', fh.read(4))[0] #4-byte little endian

	#Read triangles
	def readVector():
		return Vector(
			*struct.unpack('<fff', fh.read(3*4)) #4-byte little endian floats
			)

	ret = Mesh()
	for i in range(numTriangles):
		n = readVector()
		v0 = readVector()
		v1 = readVector()
		v2 = readVector()
		attrByteCount = struct.unpack('<H', fh.read(2))[0] #2-byte little endian
		fh.read(attrByteCount)
		ret.vertices.append(v0)
		ret.vertices.append(v1)
		ret.vertices.append(v2)
		ret.triangles.append([3*i, 3*i+1, 3*i+2])

	return ret



def save(fh, mesh):
	#TODO: make it an option to write the text format

	#Write header
	#TODO: make fully compliant header
	header = b'This is a binary STL file generated by NeSTL.'.ljust(80, b'\0')
	fh.write(header)

	#Write number of triangles
	fh.write(struct.pack('<I', len(mesh.triangles))) #4-byte little endian

	#Write triangles
	def writeVector(v):
		for coord in v:
			fh.write(struct.pack('<f', coord)) #4-byte little endian float

	for tri in mesh.triangles:
		v0 = mesh.vertices[tri[0]]
		v1 = mesh.vertices[tri[1]]
		v2 = mesh.vertices[tri[2]]
		n  = Vector() #TODO: normalized cross product
		writeVector(n)
		writeVector(v0)
		writeVector(v1)
		writeVector(v2)
		atrrByteCount = 0
		fh.write(struct.pack('<H', atrrByteCount)) #2-byte little endian

